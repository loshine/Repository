# 面向对象

## 抽象类和抽象方法

抽象方法必须在抽象类中

```dart
abstract class Doer {
  // Define instance variables and methods...

  void doSomething(); // Define an abstract method.
}

class EffectiveDoer extends Doer {
  void doSomething() {
    // Provide an implementation, so the method is not abstract here...
  }
}
```

## 隐式接口

每个类都隐式定义一个同名接口，该接口包含该类的所有实例成员及其实现的任何接口。

如果要在不继承 B 实现的情况下创建支持 B 类 API 的 A 类，则 A 类应实现 B 接口。

```dart
// A person. The implicit interface contains greet().
class Person {
  // In the interface, but visible only in this library.
  final _name;

  // Not in the interface, since this is a constructor.
  Person(this._name);

  // In the interface.
  String greet(String who) => 'Hello, $who. I am $_name.';
}

// An implementation of the Person interface.
class Impostor implements Person {
  get _name => '';

  String greet(String who) => 'Hi $who. Do you know who I am?';
}
```

## 重写操作符

如果自定义一个类，可以重写操作符来自定义该类使用该操作符的操作。

```dart
class Vector {
  final int x, y;

  Vector(this.x, this.y);

  Vector operator +(Vector v) => Vector(x + v.x, y + v.y);
  Vector operator -(Vector v) => Vector(x - v.x, y - v.y);

  // Operator == and hashCode not shown. For details, see note below.
  // ···
}
```

下表中的操作符都可以被重写



## noSuchMethod()

你可以在使用一个不存在的方法时，做出对应的反应，只需要重写`noSuchMethod`即可。

```dart
class A {
  // Unless you override noSuchMethod, using a
  // non-existent member results in a NoSuchMethodError.
  @override
  void noSuchMethod(Invocation invocation) {
    print('You tried to use a non-existent member: ' +
        '${invocation.memberName}');
  }
}
```

## mixins

mixins 是一个能重用代码的多继承解决方案。

```dart
class Musician extends Performer with Musical {
  // ···
}
```

实现一个 mixin，需要声明一个没有构造函数，没有调用`super`的类。

```dart
abstract class Musical {
  bool canPlayPiano = false;
  bool canCompose = false;
  bool canConduct = false;

  void entertainMe() {
    if (canPlayPiano) {
      print('Playing piano');
    } else if (canConduct) {
      print('Waving hands');
    } else {
      print('Humming to self');
    }
  }
}
```
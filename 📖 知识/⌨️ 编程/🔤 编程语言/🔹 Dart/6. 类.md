# 类

## 构造函数

### 默认构造函数

如果不实现任何构造函数，会有一个同名的默认构造函数。

### 创建构造函数

#### 同名构造

创建与类名相同的构造函数

```dart
class Point {
  num x, y;
  // Syntactic sugar for setting x and y
  // before the constructor body runs.
  Point(this.x, this.y);
}
```

#### 命名的构造函数

也可以给构造函数命名

```dart
class Point {
  num x, y;

  Point(this.x, this.y);

  // Named constructor
  Point.origin() {
    x = 0;
    y = 0;
  }
}
```

### 使用构造函数

你可以使用构造函数来创建类的实例对象，构造函数可以是`ClassName`或`ClassName.identifier`。

```dart
var p1 = Point(2, 2);
var p2 = Point.fromJson({'x': 1, 'y': 2});
```

构造函数也可以使用可选的`new`关键词

```dart
var p1 = new Point(2, 2);
var p2 = new Point.fromJson({'x': 1, 'y': 2});
```

有些类提供常量构造函数，要使用常量构造函数创建编译时常量，请在调用构造函数时使用`const`关键词

```dart
var a = const ImmutablePoint(1, 1);
var b = const ImmutablePoint(1, 1);

assert(identical(a, b)); // They are the same instance!
```

### 继承构造函数

构造函数调用父类构造函数。

```dart
class Person {
  String firstName;
  Person.fromJson(Map data) {
    print('in Person');
  }
}

class Employee extends Person {
  // Person does not have a default constructor;
  // you must call super.fromJson(data).
  Employee.fromJson(Map data) : super.fromJson(data) {
    print('in Employee');
  }
}
```

### 初始化列表

除了调用父类的构造函数之外，还可以在构造函数体运行之前初始化实例变量。 用逗号分隔初始化程序。

```dart
// Initializer list sets instance variables before
// the constructor body runs.
Point.fromJson(Map<String, num> json)
    : x = json['x'],
      y = json['y'] {
  print('In Point.fromJson(): ($x, $y)');
}
```

### 常量构造函数

定义`const`构造函数并确保所有实例变量都是`final`，这样就可以创建编译时常量。

```dart
class ImmutablePoint {
  static final ImmutablePoint origin = const ImmutablePoint(0, 0);

  final num x, y;

  const ImmutablePoint(this.x, this.y);
}
```

### 工厂构造函数

在实现并不总是创建其类的新实例的构造函数时，请使用`factory`关键字。 例如，工厂构造函数可能从缓存中返回实例，或者它可能返回子类型的实例。

```dart
class Logger {
  final String name;
  bool mute = false;

  // _cache is library-private, thanks to
  // the _ in front of its name.
  static final Map<String, Logger> _cache = <String, Logger>{};

  factory Logger(String name) {
    if (_cache.containsKey(name)) {
      return _cache[name];
    } else {
      final logger = Logger._internal(name);
      _cache[name] = logger;
      return logger;
    }
  }

  Logger._internal(this.name);

  void log(String msg) {
    if (!mute) print(msg);
  }
}
```

## 获取类型

使用对象的`runtimeType`属性可以获取到 **Type** 对象。

## 方法

### Getters and setters

每个属性都有一个隐式 getter，合适的还会有 setter（final 属性无 setter）。

您可以使用`get`和`set`关键字通过实现 getter 和 setter 来创建其他属性

```dart
class Rectangle {
  num left, top, width, height;

  Rectangle(this.left, this.top, this.width, this.height);

  // Define two calculated properties: right and bottom.
  num get right => left + width;
  set right(num value) => left = value - width;
  num get bottom => top + height;
  set bottom(num value) => top = value - height;
}
```
# StatefulWidget 的生命周期

![lifecycle](https://i.imgur.com/BFzYWcV.png)

## 1. createState()

当创建一个StatefulWidget时。立即调用。通常都是如下简单的操作。

```dart
class MyHomePage extends StatefulWidget {
  @override
  _MyHomePageState createState() => new _MyHomePageState();
}
```

## 2. mounted is true

当这个 Widget 调用`createState`后, 会将 buildContext 传入。 BuildContext 内有自己在 widget tree上相关的信息。

所有的 widgets 都有`bool this.mounted`这个属性，当 BuildContext 传入时，它将会被标记成`true`。如果这个属性不是`true`的话，调用`setState`会报错。

> 注意：你可以在调用`setState`前，检查一下这个变量。

```dart
if (mounted) {
  // ...` to make sure the State exists before calling `setState()`
}
```

## 3 . initState()

这个方法只会在这个 Widget 被创建之后调用一次，这个方法里必须调用`super.initState()`。

在这个方法里我们可以：

1. 初始化根据对应 BuildContext 的状态
2. 初始化根据在树上的父节点的属性确定的值
3. 注册 Streams ChangeNotifiers 或者其他会改变的数据的监听

```dart
@override
initState() {
  super.initState();
  // Add listeners to this class
  cartItemStream.listen((data) {
    _updateWidget(data);
  });
}
```

## 4. didChangeDependencies()

在`initState`方法后会被调用。

当 Widget 依赖的一些数据(比如说是 InheritedWidget)更新时，它也会立即被调用。

同时`build`方法，会自动调用。

需要注意的是，你需要通过调用`BuildContext.inheritFromWidgetOfExactType`，手动去注册 InheritedWidget 的监听后，这个方法才会起作用。

## 5.build()

这个方法会经常被调用。

## 6. didUpdateWidget(Widget oldWidget)

如果父组件发生变化，而且必须去重建 Widget 时，而且被相同的 runtimeType 重建时，这个方法会被调用。

这个方法，会自动调用`build`，所以不需要去调用`setState`

```dart
@override
void didUpdateWidget(Widget oldWidget) {
  if (oldWidget.importantProperty != widget.importantProperty) {
    _init();
  }
}
```

## 7. setState()

这个方法会被 framework 和开发者不断调用，用来通知组件刷新。

这个方法不能有异步的回调。

```dart
void updateProfile(String name) {
 setState(() => this.name = name);
}
```

## 8. deactivate()

State 从树中删除时会调用`deactivate`，但可能会在当前帧更改完成之前重新插入。

此方法的存在主要是因为 State 对象可以从树中的一个点移动到另一个点。

## 9. dispose()

State 删除对象时调用`dispose`，这是永久性的。

> 在此方法取消订阅并取消所有动画，流等

## 10. mounted is false

state 对象被移除了，如果调用`setState`，会抛出错误。
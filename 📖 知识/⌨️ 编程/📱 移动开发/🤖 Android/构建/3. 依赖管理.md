# 依赖管理

> 依赖管理是 Gradle 最闪耀的地方，你仅仅只需添加一行代码在你的build文件，Gradle 就会自动从远程仓库为你下载相关的 jar 包。

## 仓库

仓库定义了 Gradle 从哪个源获取依赖包，Android 默认使用 JCenter

```groovy
repositories {
    jcenter()
}
```

Gradle 支持三种不同的仓库：

* Maven
* Ivy
* 文件夹

依赖包会在你执行 build 构建的时候从这些远程仓库下载，并在本地保留缓存。

我们也可以添加其它仓库

```groovy
repositories {
    jcenter()
    maven { url "https://jitpack.io" }
}
```

所需的依赖会按顺序依次从仓库中检索，直到检索完成并下载缓存到本地

如果是一个需要权限才能访问的远程库，则需要验证身份

```groovy
repositories {
    maven {
        url "http://repo.acmecorp.com/maven2"
        credentials {
            username 'user'
            password 'secretpassword'
        }
    }
}
```

## 远程依赖

一个依赖需要定义三个元素：`group`，`name`和`version`

```groovy
dependencies {
    compile 'com.google.code.gson:gson:2.3'
    compile 'com.squareup.retrofit:retrofit:1.9.0'
}
```

将其展开为完整表述如下：

```groovy
dependencies {
    compile group: 'com.google.code.gson', name: 'gson', version:'2.3'
    compile group: 'com.squareup.retrofit', name: 'retrofit', version: '1.9.0'
}
```

## 本地依赖

有时候我们会导入一些不在仓库中存在的第三方 jar 包和一些 so 包，这个时候我们就需要添加本地依赖

默认情况下，新建的 Android 项目会有一个`lib`文件夹，并且会在依赖中这么定义（即添加所有在`libs`文件夹中的 jar）：

```groovy
dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
}
```

这意味着我们只需要把 jar 文件放在到`libs`文件夹下，就会自动添加本地依赖。

### native包（so包）

用 C 或者 C++ 写的 library 会被叫做 so 包，Android 插件默认情况下支持 native 包，你需要把`.so`文件放在对应的文件夹中：

```bash
app
 ├── AndroidManifest.xml
 └── jniLibs
      ├── armeabi
      │    └── nativelib.so
      ├── armeabi-v7a
      │    └── nativelib.so
      ├── mips
      │    └── nativelib.so
      └── x86
           └── nativelib.so
```

### 模块依赖

新建一个 Android Library 模块，并且将其作为 app 的依赖

首先我们新建一个 Android Library 模块，在其`build.gradle`内启用了`com.android.library`插件

然后在`setting.gradle`中添加模块

```groovy
include ':app', ':library'
```

最后在 app 中添加依赖

```groovy
dependencies {
    compile project(':library')
}
```

### aar 文件

如果想要复用模块，我们可以将其生成 aar 文件。当你构建你的 library 项目，aar 文件将会在`build/output/aar/`下生成。

把该文件作为依赖包，我们需要创建一个文件夹来放置它，我们就叫它aars文件夹吧，然后把它拷贝到该文件夹里面，然后添加该文件夹作为依赖库：

```groovy
repositories {
    flatDir {
        dirs 'aars'
    }
}

dependencies {
    compile name:'libraryname', ext:'aar'
}
```

这个会告诉 Gradle，在`aars`文件夹下，添加一个叫做`libraryname`的且其后缀名为`aar`的文件作为依赖。

## 依赖配置

我们有五种不同的依赖配置：

* ~~`compile`：默认，编译和打包的时候都会添加依赖~~
* `implementation`：本 module 不会通过自身的接口向外部暴露其依赖 module 的内容。若 A 依赖 B，B 依赖 C，A 不可调用 C 的类和方法
* `api`：替代`compile`，配合`implementation`可以加快构建
* ~~`apk`：仅在打包 apk 的时候添加依赖，编译时不添加~~
* `runtimeOnly`：替代`apk`，仅在打包 apk 的时候添加依赖，编译时不添加
* ~~`provided`：提供编译支持但不加入 apk~~
* `compileOnly`：替代`provided`
* ~~`testCompile`：测试需要的依赖，不会打包~~
* ~~`androidTestCompile`：Android 测试需要的依赖，不会打包~~
* `testImplementation`和`testApi`：Java 测试依赖
* `androidTestImplmentation`和`androidTestApi`：Android 测试依赖

这些不同的配置非常有用，比如我们可以将 **JUnit**、**Robolectric** 配置为~~testCompile~~`testImplementation`，它就可以参与单元测试但不会被打包
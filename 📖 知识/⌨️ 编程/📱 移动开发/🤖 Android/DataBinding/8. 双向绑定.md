# 双向绑定

## Before

以前我们需要自定义 Listener 进行双向绑定：

```xml
<EditText android:text=“@{user.name}”
    android:afterTextChanged=“@{callback.change}”/>
```

需要自己绑定`afterTextChanged`方法，然后检测 text 是否有改变，有改变则去修改 observable。

```java
public void change(Editable s) {
    final String text = s.toString();
    if (!text.equals(name.get()) {
        name.set(text);
    }
}
```

## Now

现在可以直接使用`@=`（而不是`@`）来进行双向绑定了，使用起来十分简单

```xml
        <EditText
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:inputType="textNoSuggestions"
            android:text="@={string}"/>
 
        <TextView
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:text="@{string}"/>
```

这样，我们对这个 EditText 的输入，就会自动 set 到对应 model 的属性上(本例中就是 string 本身)，并显示到 TextView 中

## 原理

### InverseBindingListener

`InverseBindingListener`是事件发生时触发的监听器:

```java
public interface InverseBindingListener {
    void onChange();
}
```

上述例子中生成的代码

```java
private android.databinding.InverseBindingListener mboundView1androidTe = new android.databinding.InverseBindingListener() {
        @Override
        public void onChange() {
            // Inverse of string
            //         is com.hhly.databindingdemo.databinding.ActivityTwoWayBinding.this.setString(callbackArg_0)
            java.lang.String callbackArg_0 = android.databinding.adapters.TextViewBindingAdapter.getTextString(mboundView1);
            // localize variables for thread safety
            // string
            java.lang.String string = mString;

            if ((com.hhly.databindingdemo.databinding.ActivityTwoWayBinding.this) != (null)) {

                com.hhly.databindingdemo.databinding.ActivityTwoWayBinding.this.setString(callbackArg_0);
            }
        }
    };
```

### InverseBindingAdapter & InverseBindingAdapter

可以看到我们从`TextViewBindingAdapter.getTextString`方法中获取了 String

```java
    @InverseBindingAdapter(attribute = "android:text", event = "android:textAttrChanged")
    public static String getTextString(TextView view) {
        return view.getText().toString();
    }
```

跟`BindingMethod`和`BindingAdapter`做 set 操作类似，双向绑定通过注解进行 get 操作。

也可以使用InverseBindingMethod做到一样的效果:

```java
@InverseBindingMethods({
    @InverseBindingMethod(
    type=android.widget.TextView.class,
    attribute="android:text",
    method="getText",                   // 默认会根据attribute name获取get
    event="android:textAttrChanged")})  // 默认根据attribute增加AttrChanged
```

整个双向绑定的逻辑如下

```javascript
// setter
@BindingAdapter("android:text")
public static void setText(TextView view, CharSequence text) {
    final CharSequence oldText = view.getText();
    if (text == oldText || (text == null && oldText.length() == 0)) {
        return;
    }
    if (text instanceof Spanned) {
        if (text.equals(oldText)) {
            return; // No change in the spans, so don't set anything.
        }
    } else if (!haveContentsChanged(text, oldText)) {
        return; // No content changes, so don't set anything.
    }
    view.setText(text);
}

// getter
@InverseBindingAdapter(attribute = "android:text", event = "android:textAttrChanged")
public static String getTextString(TextView view) {
    return view.getText().toString();
}

// 绑定 Listener
@BindingAdapter(value = {"android:beforeTextChanged", "android:onTextChanged",
        "android:afterTextChanged", "android:textAttrChanged"}, requireAll = false)
public static void setTextWatcher(TextView view, final BeforeTextChanged before,
        final OnTextChanged on, final AfterTextChanged after,
        final InverseBindingListener textAttrChanged) {
    final TextWatcher newValue;
    if (before == null && after == null && on == null && textAttrChanged == null) {
        newValue = null;
    } else {
        newValue = new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence s, int start, int count, int after) {
                if (before != null) {
                    before.beforeTextChanged(s, start, count, after);
                }
            }

            @Override
            public void onTextChanged(CharSequence s, int start, int before, int count) {
                if (on != null) {
                    on.onTextChanged(s, start, before, count);
                }
                if (textAttrChanged != null) {
                    textAttrChanged.onChange();
                }
            }

            @Override
            public void afterTextChanged(Editable s) {
                if (after != null) {
                    after.afterTextChanged(s);
                }
            }
        };
    }
    final TextWatcher oldValue = ListenerUtil.trackListener(view, newValue, R.id.textWatcher);
    if (oldValue != null) {
        view.removeTextChangedListener(oldValue);
    }
    if (newValue != null) {
        view.addTextChangedListener(newValue);
    }
}
```

整体流程如下：

1. data binding 通过`textAttrChanged`的 event 找到`setTextWatcher`方法
2. `setTextWatcher`通知`InverseBindingListener`的`onChange`方法
3. `onChange`方法使用找到的 getter 和 setter 方法去进行检查和更新
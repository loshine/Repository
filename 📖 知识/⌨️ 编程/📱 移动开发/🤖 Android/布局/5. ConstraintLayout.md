# ConstraintLayout

## 什么是 ConstraintLayout

ConstraintLayout 是约束布局

## 使用

### 位置约束

- `layout_constraintLeft_toLeftOf`
- `layout_constraintLeft_toRightOf`
- `layout_constraintRight_toLeftOf`
- `layout_constraintRight_toRightOf`
- `layout_constraintTop_toTopOf`
- `layout_constraintTop_toBottomOf`
- `layout_constraintBottom_toTopOf`
- `layout_constraintBottom_toBottomOf`
- `layout_constraintBaseline_toBaselineOf`
- `layout_constraintStart_toEndOf`
- `layout_constraintStart_toStartOf`
- `layout_constraintEnd_toStartOf`
- `layout_constraintEnd_toEndOf`

这些属性可以是`parent`或者`@id`

ConstraintLayout 可以用来取代 RelativeLayout，减少嵌套布局。关于 left、right、top、bottom、start、end、baseline 的基准可以参照下图

![position](https://i.imgur.com/Aidh8uo.png)

### 边距约束

除了普通的 Margin，约束布局还提供了当依赖的约束对象的 visibility 被设置为 gone 时的边距约束：

- `layout_goneMarginStart`
- `layout_goneMarginEnd`
- `layout_goneMarginLeft`
- `layout_goneMarginRight`
- `layout_goneMarginTop`
- `layout_goneMarginBottom`

### 偏压约束

偏压约束只有在控件设置好横向或者纵向约束的时候才会起作用

- `layout_constraintHorizontal_bias`
- `layout_constraintVertical_bias`

### 大小

约束布局不支持`match_parent`属性，它只支持以下三种属性：

- `wrap_content`
- 指定大小
- 0dp（填充约束）

### 比例

`layout_constraintDimentionRatio`属性可以用来设置控件的宽高比例。默认是宽高比，也可以如下设置为高宽比：

```xml
app:layout_constraintDimensionRatio="H,2:1"
```

### Chain

约束布局也可以完成原来 LinearLayout 的工作：

![chain](https://i.imgur.com/Rur9TL4.gif)

如上操作让三个按钮在水平方向形成了一条 Chain，且底部对齐。

在 xml 文件中， ButtonA 新增了一条属性`app:layout_constraintHorizontal_chainStyle`，这个属性在一条 Chain 中只会出现在第一个控件中，这个控件是整条 Chain 的 Head。

![horizontal-chain](https://i.imgur.com/7Tjtgxb.png)

ChainStyle 属性可以设置水平和竖直方向，分别有三种属性：`spread`,`spread_inside`,`packed`

如果将控件的`layout_width`和`layout_height`设置成为`0dp`，还可以配合`layout_constraintHorizontal_weight`、`layout_constraintVertical_weight`两个属性实现和 LinearLayout 中设置`layout_weight`相同的效果

![chain-weight](https://i.imgur.com/rxCtjDT.png)

### Guideline

Guideline 是用来辅助布局的 View，可以使用`layout_constraintGuide_begin`和`layout_constraintGuide_end`设置具体dp值，也可以使用`layout_constraintGuide_percent`来设置比例。

![guideline](https://i.imgur.com/r58OU34.png)

### Circular Position

```xml
app:layout_constraintCircle="@+id/sun_image"
app:layout_constraintCircleAngle="45"
app:layout_constraintCircleRadius="90dp"
```

![circular1](https://i.imgur.com/YIDr9hU.png)![circular2](https://i.imgur.com/BDeSF3X.png)

### Percent Dimensions

在`1.1.x`版本中，`layout_constraintWidth_default`和`layout_constraintHeight_default`属性新增了`percent`值，允许我们设置控件占据可用空间的百分比。

```xml
app:layout_constraintHeight_default="percent"
app:layout_constraintHeight_percent="0.5"
app:layout_constraintWidth_default="percent"
app:layout_constraintWidth_percent="0.5"
```

### Ratio

Ratio 属性可以方便快捷的设置宽高比。

```xml
app:layout_constraintDimensionRatio="h,15:9"
```

> `h`代表`horizental`

## Barrier

Barrier 是一个虚拟的辅助控件，它可以阻止一个或者多个控件越过自己，就像一个屏障一样。当某个控件要越过自己的时候，Barrier 会自动移动，避免自己被覆盖。

如下例中，不管 text1 和 text2有多长，或者哪个更长，它们的 end 都不会越过 Barrier。而 text3 因为约束在 Barrier 的后面，所以也就保证了 text3 总是在 text1 和 text2 后面。

```xml
    <android.support.constraint.ConstraintLayout...>
      <TextView
        android:id="@+id/text1" ... />
      <TextView
        android:id="@+id/text2" ... />
      <android.support.constraint.Barrier
        android:id="@+id/barrier"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:barrierDirection="end"
        app:constraint_referenced_ids="text1,text2" />
      <TextView
        android:id="@+id/text3"
        ...
        app:layout_constraintStart_toEndOf="@+id/barrier" />
    </android.support.constraint.ConstraintLayout>
```

![barrier](https://i.imgur.com/lqy8Mce.png)

### Group

Group 帮助你对一组控件进行设置。最常见的情况是控制一组控件的 visibility。你只需把控件的 id 添加到 Group，就能同时对里面的所有控件进行操作。

```xml
    <android.support.constraint.ConstraintLayout ...>
      <TextView
        android:id=”@+id/text1" ... />
      <TextView
        android:id=”@+id/text2" ... />
      <android.support.constraint.Group
        android:id=”@+id/group”
        ...
        app:constraint_referenced_ids=”text1,text2" />
    </android.support.constraint.ConstraintLayout>
```

此时，就可以使用 group 同时操作 text1 和 text2

```java
group.setVisibility(View.GONE);
```

### Placeholder

Placeholder 顾名思义，就是用来一个占位的东西，它可以把自己的内容设置为 ConstraintLayout 内的其它 view。因此它用来写布局的模版，也可以用来动态修改 UI 的内容。

#### 模板

我们用 Placeholder 创建一个名为`template.xml`的模版：

```xml
    <?xml version="1.0" encoding="utf-8"?>
    <merge xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        xmlns:tools="http://schemas.android.com/tools"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:layout_editor_absoluteX="0dp"
        tools:layout_editor_absoluteY="81dp"
        tools:parentTag="android.support.constraint.ConstraintLayout">

        <android.support.constraint.Placeholder
            android:id="@+id/template_main_image"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:layout_marginTop="16dp"
            app:content="@+id/top_image"
            app:layout_constraintDimensionRatio="16:9"
            app:layout_constraintLeft_toLeftOf="parent"
            app:layout_constraintRight_toRightOf="parent" />

        <android.support.constraint.Placeholder
            android:id="@+id/template_save"
            android:layout_width="48dp"
            android:layout_height="48dp"
            app:content="@+id/save"
            app:layout_constraintEnd_toStartOf="@+id/template_delete"
            app:layout_constraintHorizontal_bias="0.5"
            app:layout_constraintStart_toStartOf="parent"
            tools:layout_editor_absoluteY="460dp" />

        <android.support.constraint.Placeholder
            android:id="@+id/template_delete"
            android:layout_width="48dp"
            android:layout_height="48dp"
            app:content="@+id/delete"
            app:layout_constraintEnd_toStartOf="@+id/template_cancel"
            app:layout_constraintHorizontal_bias="0.5"
            app:layout_constraintStart_toEndOf="@+id/template_save"
            tools:layout_editor_absoluteY="460dp" />

        <android.support.constraint.Placeholder
            android:id="@+id/template_cancel"
            android:layout_width="48dp"
            android:layout_height="48dp"
            app:content="@+id/cancel"
            app:layout_constraintEnd_toStartOf="@+id/template_edit"
            app:layout_constraintHorizontal_bias="0.5"
            app:layout_constraintStart_toEndOf="@+id/template_delete"
            tools:layout_editor_absoluteY="460dp" />

        <android.support.constraint.Placeholder
            android:id="@+id/template_edit"
            android:layout_width="48dp"
            android:layout_height="48dp"
            app:content="@+id/edit"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintHorizontal_bias="0.5"
            app:layout_constraintStart_toEndOf="@+id/template_cancel"
            tools:layout_editor_absoluteY="460dp" />

    </merge>
```

每个 PlaceHolder 都设置了自己的`app:content`属性，比如`app:content="@+id/edit"`，表示用 id 为 edit 的控件来填充这个位置。

![place_holder](https://i.imgur.com/J2bbOkL.png)

我们把刚才定义的模版 include 到真正的布局文件中，并且在这个布局文件中添加真实的控件，注意这里的控件无需添加任何约束，因为它们的位置是由 Placeholder 决定的。

```xml
    <?xml version="1.0" encoding="utf-8"?>
    <android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        xmlns:tools="http://schemas.android.com/tools"
        android:id="@+id/root"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:layout_behavior="@string/appbar_scrolling_view_behavior"
        tools:context="com.app.androidkt.constraintlayoutb.MainActivity"
        tools:showIn="@layout/activity_main">
        <include layout="@layout/template" />
        <ImageView
            android:id="@+id/top_image"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:scaleType="fitXY"
            android:src="@drawable/place_holder_demo" />

        <ImageButton
            android:id="@+id/save"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp"
            app:layout_constraintBottom_toBottomOf="parent"
            app:srcCompat="@drawable/ic_save_black_24dp" />

        <ImageButton
            android:id="@+id/edit"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            app:srcCompat="@drawable/ic_edit_black_24dp" />

        <ImageButton
            android:id="@+id/cancel"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp"

            app:srcCompat="@drawable/ic_cancel_black_24dp" />

        <ImageButton
            android:id="@+id/delete"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginBottom="16dp"
            app:srcCompat="@drawable/ic_delete_black_24dp" />

    </android.support.constraint.ConstraintLayout>
```

![template](https://i.imgur.com/eVjhrvg.png)

#### 动态替换

PlaceHolder 还可以在 Java 代码中动态替换自己的内容：

```java
    public class MainActivity extends AppCompatActivity {
        private Placeholder placeholder;
        private ConstraintLayout root;

        @Override
        public void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);
            ...
        }

        public void onClick(View view) {
            placeholder.setContentId(view.getId());
        }
    }
```

如果结合过渡动画的话，就可以实现一些比较有趣的效果：

![animation](https://i.imgur.com/eBzhFs7.gif)

```java
    public class MainActivity extends AppCompatActivity {
        private Placeholder placeholder;
        private ConstraintLayout root;
        @Override
        public void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);
            ...
        }
        public void onClick(View view) {
            TransitionManager.beginDelayedTransition(root);
            placeholder.setContentId(view.getId());
        }
    }
```
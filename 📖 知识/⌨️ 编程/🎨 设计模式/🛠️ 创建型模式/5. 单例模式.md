# 单例模式

## 定义

单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。

## 结构

单例模式包含如下角色：

* **Singleton**：单例

![Singleton](https://i.imgur.com/oIxGOJF.png)

## 示例

### 饿汉式

一般开发中使用饿汉式。

```java
public class Emperor {
    // 饿汉式，开始就建立一个对象
    private static final Emperor e = new Emperor();

    // 将构造函数私有，禁止在其它类中创建对象
    private Emperor() {
    }

    public static Emperor getInstance() {
        return e;
    }
}
```

### 懒汉式

```java
public class Emperor {

   // 懒汉式，刚开始不建立对象
   private volatile static Emperor e;

   // 将构造函数私有，禁止在其它类中创建对象
   private Emperor() {
   }

   public static Emperor getInstance() {
       if (e == null) {
           synchronized (Emperor.class) {
               // 如果没有则创建
               if (e == null) {
                   e = new Emperor();
               }
           }
       }
       return e;
   }
}
```

### 枚举实现

```java
public enum Singleton {
    INSTANCE;
}
```

### 内部类实现

```java
public class Singleton {
    /**
     * 类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例没有绑定关系，
     * 而且只有被调用到才会装载，从而实现了延迟加载
     */
    private static class SingletonHolder {
        /**
         * 静态初始化器，由JVM来保证线程安全
         */
        private static final Singleton instance = new Singleton();
    }
    /**
     * 私有化构造方法
     */
    private Singleton() {
    }

    public static Singleton getInstance() {
        return SingletonHolder.instance;
    }
}
```

### 容器实现

使用一个容器管理所有的单例，通过方法获取：

```java
public class SingletonManager {

    private static Map<String, Object> cache = new HashMap<String, Object>();

    private SingletonManager() {
    }

    public static void registerObject(String key, Object instance) {
        if (!cache.containsKey(key)) {
            cache.put(key, instance);
        }
    }

    public static Object getObject(String key) {
        return cache.get(key);
    }
}
```

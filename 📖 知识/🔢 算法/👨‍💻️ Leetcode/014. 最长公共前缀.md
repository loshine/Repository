# 最长公共前缀

## 题目

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串`""`。

> 所有输入只包含小写字母`a-z`。

## 解题

### 1. 横向对比

比较简单，一个一个对比公共最长前缀即可

### 2. 分治法

![分治](https://i.imgur.com/FKmoXpW.png)

```kotlin
class Solution {
    fun longestCommonPrefix(strs: Array<String>): String {
        return if (strs.isEmpty()) "" else longestCommonPrefix(strs, 0, strs.size - 1)
    }

    private fun longestCommonPrefix(strs: Array<String>, l: Int, r: Int): String {
        return if (l == r) {
            strs[l]
        } else {
            val mid = (l + r) / 2
            val lcpLeft = longestCommonPrefix(strs, l, mid)
            val lcpRight = longestCommonPrefix(strs, mid + 1, r)
            commonPrefix(lcpLeft, lcpRight)
        }
    }

    fun commonPrefix(left: String, right: String): String {
        val min = Math.min(left.length, right.length)
        for (i in 0 until min) {
            if (left[i] != right[i])
                return left.substring(0, i)
        }
        return left.substring(0, min)
    }
}
```

### 3. 二分查找

![二分查找](https://i.imgur.com/WZu3VAO.png)

```kotlin
class Solution {
    fun longestCommonPrefix(strs: Array<String>): String {
        if (strs.isEmpty())
            return ""
        var minLen = Integer.MAX_VALUE
        for (str in strs)
            minLen = Math.min(minLen, str.length)
        var low = 1
        var high = minLen
        while (low <= high) {
            val middle = (low + high) / 2
            if (isCommonPrefix(strs, middle))
                low = middle + 1
            else
                high = middle - 1
        }
        return strs[0].substring(0, (low + high) / 2)
    }

    private fun isCommonPrefix(strs: Array<String>, len: Int): Boolean {
        val str1 = strs[0].substring(0, len)
        for (i in 1 until strs.size)
            if (!strs[i].startsWith(str1))
                return false
        return true
    }
}
```
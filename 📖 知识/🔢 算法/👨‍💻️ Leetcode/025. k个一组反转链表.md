# 题目

给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。

k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。

**示例 :**

给定这个链表：`1->2->3->4->5`

当 k = 2 时，应当返回: `2->1->4->3->5`

当 k = 3 时，应当返回: `3->2->1->4->5`

# 解题

以 K 为一组进行翻转，翻转时一个一个往后放，做多次循环即可。

```kotlin
/**
 * Definition for singly-linked list.
 * class ListNode(var `val`: Int = 0) {
 *     var next: ListNode? = null
 * }
 */
class Solution {
    
    fun reverseKGroup(head: ListNode?, k: Int): ListNode? {
        var h = head

        // 特殊情况直接返回，不需要翻转
        if (h?.next == null || k < 2) return h

        val dummy = ListNode(0)
        dummy.next = h

        var tail: ListNode? = dummy
        var prev: ListNode? = dummy
        var temp: ListNode
        var count: Int
        while (true) {
            count = k
            // 需要数量 > 0 且 尾部还有元素
            while (count > 0 && tail != null) {
                count--
                tail = tail.next
            }
            // 到末尾了就结束内循环
            if (tail == null) break

            // for next cycle
            h = prev!!.next
            // prev-->temp-->...--->....--->tail-->....
            // Delete @temp and insert to the next position of @tail
            // prev-->...-->...-->tail-->head-->...
            // Assign @temp to the next node of @prev
            // prev-->temp-->...-->tail-->...-->...
            // Keep doing until @tail is the next node of @prev
            while (prev.next !== tail) {
                temp = prev.next!!// Assign
                prev.next = temp.next// Delete

                temp.next = tail.next
                tail.next = temp// Insert
            }
            tail = h
            prev = h
        }
        return dummy.next
    }
}
```